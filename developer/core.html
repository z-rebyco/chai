<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>核心（pychai.core） | 汉字自动拆分系统</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="一种现代的方法">
    <link rel="preload" href="/chai/assets/css/0.styles.222d323b.css" as="style"><link rel="preload" href="/chai/assets/js/app.6d1c78da.js" as="script"><link rel="preload" href="/chai/assets/js/2.88830754.js" as="script"><link rel="preload" href="/chai/assets/js/9.eede7e9f.js" as="script"><link rel="prefetch" href="/chai/assets/js/10.2b767715.js"><link rel="prefetch" href="/chai/assets/js/11.860de3e0.js"><link rel="prefetch" href="/chai/assets/js/12.e27c9830.js"><link rel="prefetch" href="/chai/assets/js/3.e1c41710.js"><link rel="prefetch" href="/chai/assets/js/4.8833f35d.js"><link rel="prefetch" href="/chai/assets/js/5.1d680d98.js"><link rel="prefetch" href="/chai/assets/js/6.2e43f1f5.js"><link rel="prefetch" href="/chai/assets/js/7.fe96df9f.js"><link rel="prefetch" href="/chai/assets/js/8.eba41bc3.js">
    <link rel="stylesheet" href="/chai/assets/css/0.styles.222d323b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/chai/" class="home-link router-link-active"><!----> <span class="site-name">汉字自动拆分系统</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/chai/" aria-current="page" class="sidebar-link">概述</a></li><li><section class="sidebar-group depth-0"><a href="/chai/developer/" class="sidebar-heading clickable router-link-active open"><span>开发者文档</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/chai/developer/base.html" class="sidebar-link">基础（pychai.base）</a></li><li><a href="/chai/developer/core.html" aria-current="page" class="active sidebar-link">核心（pychai.core）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chai/developer/core.html#基类-core-chai-chai" class="sidebar-link">基类（core.chai.Chai）</a></li><li class="sidebar-sub-header"><a href="/chai/developer/core.html#顺序中间类-core-sequential-sequential" class="sidebar-link">顺序中间类（core.sequential.Sequential）</a></li><li class="sidebar-sub-header"><a href="/chai/developer/core.html#二分中间类-core-dichotomous-dichotomous" class="sidebar-link">二分中间类（core.dichotomous.Dichotomous）</a></li><li class="sidebar-sub-header"><a href="/chai/developer/core.html#四角中间类-core-tetragonal-tetragonal" class="sidebar-link">四角中间类（core.tetragonal.Tetragonal）</a></li></ul></li><li><a href="/chai/developer/preset.html" class="sidebar-link">预设（pychai.preset）</a></li><li><a href="/chai/developer/cache.html" class="sidebar-link">缓存（pychai.cache）</a></li><li><a href="/chai/developer/util.html" class="sidebar-link">工具（pychai.util）</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="核心-pychai-core"><a href="#核心-pychai-core" class="header-anchor">#</a> 核心（<code>pychai.core</code>）</h1> <h2 id="基类-core-chai-chai"><a href="#基类-core-chai-chai" class="header-anchor">#</a> 基类（<code>core.chai.Chai</code>）</h2> <h3 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h3> <p>读取各数据库、缓存、配置等。</p> <h3 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h3> <p>公有方法：</p> <ul><li><code>Chai.getComponentScheme</code>：生成所有部件拆分，结果保存到 <code>Chai.COMPONENTS</code> 的各个部件中；</li> <li><code>Chai.getCompoundScheme</code>：生成所有复合体拆分，结果保存到 <code>Chai.COMPOUNDS</code> 的各个部件中；</li> <li><code>Chai.encode</code>：</li></ul> <p>以上三个公有方法均有一个同名的私有方法与之对应，但是私有方法的签名是 <code>(self, character: Character)</code>。</p> <h3 id="输出函数-chai-chai"><a href="#输出函数-chai-chai" class="header-anchor">#</a> 输出函数（<code>Chai.chai</code>）</h3> <p>依次调用上述三个方法，并把得到的码表保存到给定路径下。</p> <h2 id="顺序中间类-core-sequential-sequential"><a href="#顺序中间类-core-sequential-sequential" class="header-anchor">#</a> 顺序中间类（<code>core.sequential.Sequential</code>）</h2> <h3 id="幂字典生成-sequential-addpowerdict"><a href="#幂字典生成-sequential-addpowerdict" class="header-anchor">#</a> 幂字典生成（<code>Sequential.__addPowerDict</code>）</h3> <p>我们现在讨论：给定一个基本部件，我们可以从其中拆出哪些字根？为了满足不同方案的需求，「拆」采用了比较激进的方案——枚举一个基本部件的所有切片，计算该切片的特征，然后在退化字典中查找它所对应的字根，如果能够找到则标记为有效切片，找不到则标记为无效切片。</p> <p>那么，一个基本部件最多能形成多少种切片？显然，对于一个 n 笔的字，每个笔画都有取和不取两种状态，因而切片就有 2 的 n 次方种可能性。我们因此可以用 n 个布尔值（即 0 或 1）组成的向量来表达这一切片。例如：</p> <ul><li>设字 c 是含有 5 笔的字，则它的所有切片都可以用一个<strong>含有 5 个布尔值的向量</strong>表达；</li> <li>取字 c 前 2 笔和最后一笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的向量应该是 (1, 1, 0, 0, 1)；</li> <li>取完切片 s 之后，余下部分 r 对应的向量应该是 (0, 0, 1, 1, 0)。</li></ul> <p>进一步抽象之后，我们很自然地联想到可以使用二进制数来表达切片，这样的好处是我们可以通过位运算来快速处理切片。例如：</p> <ul><li>设字 c 是含有 5 笔的字，则它的所有切片都可以用一个<strong>含有 5 个位的二进制数</strong>表达；</li> <li>取字 c 前 2 笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的二进制数应该是 11001，转换为十进制数是 25；</li> <li>取完切片 s 之后，余下部分 r 对应的向量应该是 00111，转换为十进制数是 6。</li></ul> <p>现在，我们就可以通过遍历 1 ~ 2<sup>n</sup>-1 的所有数字来寻找一个字的所有有效切片：</p> <p>现在，幂字典中记录了每个切片分别对应哪个字根（或者不对应任何字根），由此我们可以正式进入一个字的拆分环节。</p> <h3 id="可行拆分集生成-sequential-addschemelist"><a href="#可行拆分集生成-sequential-addschemelist" class="header-anchor">#</a> 可行拆分集生成（<code>Sequential.__addSchemeList</code>）</h3> <p>在未开始拆分之前，我们将一个字的状态用 2<sup>n</sup>-1 表示，我们将它称为剩余数。每当我们从这个字上取下一个切片时，我们就将这个切片对应的数从剩余数中减去，得到新的剩余数。那么给定任意一个剩余数，我们如何知道从它身上能取下哪些切片呢？</p> <p>首先，我们要引入一个限定原则（首笔序原则），即拆分得到的字根列表是按它们首笔笔顺排列的。因此，在每次从没有拆完的部分中取切片的过程中，必须取到该部分的第一笔。例如，第一次拆分时必须取到该字的第一笔。</p> <p>所以，拆分算法可以概括为：</p> <ul><li>建立两个列表记录拆分状态，一个为未完成列表，一个为完成列表，向未完成列表中加入初始值 (2<sup>n</sup> - 1)，即将整个部件作为一个剩余数；</li> <li>取未完成列表中的某个拆分，将它的最后一个数（即剩余数）经由 <code>nextRoot</code> 函数处理，得到所有可能切片，用幂字典检验它们的有效性，如果无效则予以剔除，有效则保留；</li> <li>如果切片恰好等于剩余数，说明这个基本部件被拆完了，我们将它添加到已完成列表中；否则用剩余数减去新切片，将它添加到未完成列表中，形成堆栈；</li> <li>重复上述过程，直到未完成列表全部被清空。</li></ul> <h2 id="二分中间类-core-dichotomous-dichotomous"><a href="#二分中间类-core-dichotomous-dichotomous" class="header-anchor">#</a> 二分中间类（<code>core.dichotomous.Dichotomous</code>）</h2> <p>TODO</p> <h2 id="四角中间类-core-tetragonal-tetragonal"><a href="#四角中间类-core-tetragonal-tetragonal" class="header-anchor">#</a> 四角中间类（<code>core.tetragonal.Tetragonal</code>）</h2> <p>TODO</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/chai/developer/base.html" class="prev">
        基础（pychai.base）
      </a></span> <span class="next"><a href="/chai/developer/preset.html">
        预设（pychai.preset）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div class="vuepress-eqn"></div><span class="vuepress-eq"></span></div></div>
    <script src="/chai/assets/js/app.6d1c78da.js" defer></script><script src="/chai/assets/js/2.88830754.js" defer></script><script src="/chai/assets/js/9.eede7e9f.js" defer></script>
  </body>
</html>

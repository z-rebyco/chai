(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{355:function(t,a,s){"use strict";s.r(a);var n=s(17),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"一、安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、安装"}},[t._v("#")]),t._v(" 一、安装")]),t._v(" "),s("p",[t._v("您可以在 PyPI 上下载汉字自动拆分系统：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("pip3 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" pychai\n")])])]),s("p",[t._v("该系统依赖 PyYAML，如您尚未安装，将在安装「拆」时自动安装。您也可以通过命令 "),s("code",[t._v("pip3 install PyYAML")]),t._v(" 手动安装。")]),t._v(" "),s("h2",{attrs:{id:"二、配置文件编写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、配置文件编写"}},[t._v("#")]),t._v(" 二、配置文件编写")]),t._v(" "),s("p",[t._v("由于本系统的高度模块化特性，您可以通过编写简单的配置文件的方式来指定一个输入方案的绝大部分信息。让我们以 98 五笔 "),s("code",[t._v("wubi98.schema.yaml")]),t._v(" 为例进行解说。")]),t._v(" "),s("h3",{attrs:{id:"_1-获取示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-获取示例"}},[t._v("#")]),t._v(" 1 获取示例")]),t._v(" "),s("p",[t._v("您可以用两行简单的程序将本系统的预置方案的配置文件和编码程序调用出来。例如，您可以编写")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" pychai "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" example\nexample"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'wubi98'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这会将 "),s("code",[t._v("wubi98.schema.yaml")]),t._v(" 拷贝到您的当前工作目录下。一同拷贝的还有 "),s("code",[t._v("wubi98.py")]),t._v("，它是适用于该方案的编码程序，我们现阶段还暂时用不到。")]),t._v(" "),s("p",[t._v("除了传入参数 "),s("code",[t._v("wubi98")]),t._v(" 之外，您也可以传入 "),s("code",[t._v("fingertip")]),t._v("（一个二分风格形码方案）或 "),s("code",[t._v("xiaoqing")]),t._v("（一个二笔方案）来获得相应的文件。")]),t._v(" "),s("h3",{attrs:{id:"_2-理解-schema"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-理解-schema"}},[t._v("#")]),t._v(" 2 理解 "),s("code",[t._v("schema")])]),t._v(" "),s("p",[t._v("配置文件的第一部分是方案基本信息。这一部分不会对方案的制作产生影响，但出于方便交流考虑，建议您留下您的个人信息。例如：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("schema")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 五笔字型 98 版\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("version")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0.1"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("author")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 发明人 王永民\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 重建人 蓝落萧 2320693692@qq.com\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("description")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),s("span",{pre:!0,attrs:{class:"token scalar string"}},[t._v("\n    用于测试自动拆分")]),t._v("\n")])])]),s("hr"),t._v(" "),s("p",[t._v("下面我们来指定方案的拆分规则。")]),t._v(" "),s("h3",{attrs:{id:"_3-理解-degenerator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-理解-degenerator"}},[t._v("#")]),t._v(" 3 理解 "),s("code",[t._v("degenerator")])]),t._v(" "),s("p",[s("code",[t._v("degenerator")]),t._v(" 者，中文名曰「退化映射」也。退化映射是本系统最重要的概念，没有之一。这是因为：「拆」的数据库中精确存储了汉字的图形信息，退化映射决定了您希望不同的图形在何种程度上可以被视为同一个字根。例如：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("degenerator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 笔画序列\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 笔画拓扑\n")])])]),s("p",[t._v("笔画序列的含义是，当待拆分的汉字中含有与给定字根相同的笔画顺序时，我们才能够从该字中拆出给定的字根。例如，对于「月」字根，「用」字中包含该字根，而「青」字中不含有该字根，因为「青」的下部第一笔为「竖」。")]),t._v(" "),s("p",[t._v("笔画拓扑的含义是，在笔画序列的基础上，我们还要进一步考虑笔画之间的关系。例如，「工」和「土」具有完全相同的笔画序列，但「土」的第一二笔为相交关系，「工」为相连关系，它们并不相同。添加「笔画拓扑」之后，这种情况就能够得以区分。")]),t._v(" "),s("p",[t._v("目前，我们仅预设了这两个组件，如果您希望指定更细致的退化映射，请您了解开发者文档并进行相关算法的编写。")]),t._v(" "),s("h3",{attrs:{id:"_4-理解-selector"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-理解-selector"}},[t._v("#")]),t._v(" 4 理解 "),s("code",[t._v("selector")])]),t._v(" "),s("p",[s("code",[t._v("selector")]),t._v(" 者，中文名曰「择优函数」也。经过 "),s("code",[t._v("degenerator")]),t._v(" 处理后，我们得到了汉字的多种可能拆分方式。此时，我们根据一系列规则确定选取哪种拆分方式。例如：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("selector")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 根少优先\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 笔顺优先\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 能连不交、能散不连\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" 取大优先\n")])])]),s("ul",[s("li",[t._v("根少优先，即拆出的字根数应该尽量少。")]),t._v(" "),s("li",[t._v("笔顺优先，即拆分应该尽可能符合笔顺。")]),t._v(" "),s("li",[t._v("能连不交、能散不连，即拆出的字根应该尽量为「散」关系，其次为「连」关系，最次为「交」关系。")]),t._v(" "),s("li",[t._v("取大优先，即拆分出的字根排在前面的笔画应该尽量多。")])]),t._v(" "),s("p",[t._v("同样，我们目前仅预设了这四个组件，如果您希望指定更细致的择优函数，请您了解开发者文档并进行相关算法的编写。")]),t._v(" "),s("p",[t._v("值得注意的是，"),s("code",[t._v("degenerator")]),t._v(" 各组件的顺序对拆分结果无影响，但 "),s("code",[t._v("selector")]),t._v(" 各组件的顺序对拆分结果有影响。作为实例，请考虑「平」的拆分：给定字根「一、丷、十、干」，若组件的顺序如上，则拆为「干、丷」；若「笔顺优先」调整到最前面，则拆为「一、丷、十」。")]),t._v(" "),s("p",[t._v("那么，我们如何确定我们给出的规则一定能确定唯一的拆分方式呢？对于这个问题我们没有一般的回答，但可以证明，当「笔顺优先」和「取大优先」均出现（不管顺序如何，也不管有什么其他的组件）时，能确定唯一的拆分方式。因此，如果您没有详细地考虑过其余选择方案的唯一性，建议保证包含这两者。")]),t._v(" "),s("p",[t._v("拆分规则至此结束，下面我们来指定方案的字根。")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"_5-理解-classifier"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-理解-classifier"}},[t._v("#")]),t._v(" 5 理解 "),s("code",[t._v("classifier")])]),t._v(" "),s("p",[t._v("我们注意到，许多方案将汉字的笔画进行了分类，这使得作者和用户可以笼统地掌握笔画而不用掌握每一种情况。在国家标准黑体类字形中，笔画共有 31 种，但绝大多数方案将它们分为 5 至 7 类。最流行的划分方案是国家标准、五笔、二笔等采用的五分法：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("classifier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("横"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 提"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("竖"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 竖钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("撇"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("点"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 捺"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("横钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横撇"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横斜钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折提"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折折"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折弯"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横撇弯钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折弯钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折折撇"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折折折"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 横折折折钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n      竖提"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 竖折"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 竖弯"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 竖弯钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 竖折撇"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 竖折折钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 竖折折"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n      撇点"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 撇折"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 弯钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 斜钩"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("p",[t._v("进行分类意味着同一类中的笔画将放置在相同的键位上。")]),t._v(" "),s("h3",{attrs:{id:"_6-理解-mapper"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-理解-mapper"}},[t._v("#")]),t._v(" 6 理解 "),s("code",[t._v("mapper")])]),t._v(" "),s("p",[t._v("在这一步，我们将字根映射到指定的键位上。例如：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("mapper")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("g")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 王"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 青上"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 五"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 夫"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 夫上"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 举下"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 年下"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 舛右"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("幺"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 双折"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 纟"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 母"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 彖上"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 贯上"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 弓"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 匕"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 化右"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 比左"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("p",[t._v("这里「键位」不一定需要为实体按键，也可以是虚拟的键名。作为实例，请参考 "),s("code",[t._v("fingertip.schema.yaml")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_7-理解-aliaser"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-理解-aliaser"}},[t._v("#")]),t._v(" 7 理解 "),s("code",[t._v("aliaser")])]),t._v(" "),s("p",[t._v("您可能已经注意到了：在 "),s("code",[t._v("mapper")]),t._v(" 中，字根分为两类：")]),t._v(" "),s("ul",[s("li",[t._v("一类为单个字符，如「王」；")]),t._v(" "),s("li",[t._v("一类为多个字符，如「年下」；")])]),t._v(" "),s("p",[t._v("单个字符所描述的字根就是它本身，而多个字符所描述的字根是非成字字根，可以任意命名。那么，我们何从知道多个字符描述的具体是什么字根呢？这就需要通过「别名注册器」进行注册：")]),t._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("aliaser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("夫上")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("夫"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),s("p",[t._v("这里，我们指定「夫上」是由源字「夫」的第 0 笔至第 2 笔构成的字根（"),s("strong",[t._v("请注意：这里从 0 开始计数！字的笔画为第 0 笔、第 1 笔、……")]),t._v("）。这样，系统通过结合图形数据，即可知道「夫上」的形状如何了。")]),t._v(" "),s("p",[t._v("请注意，别名注册器所接受的源字必须是一个基本部件，否则将无法识别。为了防止生成码表时出现错误，您可以先用我们提供的测试工具进行测试：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" pychai "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" lookup\nlookup"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'夫'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("此时有可能出现三种情况。本例中「夫」是一个基本部件，所以返回成功信息：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("恭喜！您现在可以为该字根起一个名字，在 mapper 中添加这个字根的名字，并在 aliaser 中注册，语法如下：\n【名字】: [夫, [0, 1, 2]]\n")])])]),s("p",[t._v("但如果您使用的源字是「规」，虽然规的前三笔也是夫的前三笔，但是它会提示：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("提供的汉字「规」不是基本部件，它的结构为：[h, 夫, 见]。请尝试将您需要的字根定位到这些基本部件中，然后重新查询。\n")])])]),s("p",[t._v("这表明您必须先将字根定位到基本部件中才能进行查询。最后，如果您提供的是一个非 GB 汉字，则本系统无法帮您查询，将提示「您提供的汉字「X」不在 GB 字集内。请您使用常用汉字查询字根。」。")]),t._v(" "),s("p",[t._v("不过，在查看 "),s("code",[t._v("wubi98.schema.yaml")]),t._v(" 时，您可能注意到，有一部分多个字符描述的字根无需注册。这是因为，这些名称已经是数据库中存储基本部件时使用的名称。您可以参考该方案的 "),s("code",[t._v("mapper")]),t._v(" 模块找出您所需要的名称，如果没有发现再进行定义。")]),t._v(" "),s("h2",{attrs:{id:"三、码表输出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、码表输出"}},[t._v("#")]),t._v(" 三、码表输出")]),t._v(" "),s("p",[t._v("然而，仅仅编写配置文件并不能满足每个人对于取码编码的不同需求。因此，本系统仍然要求使用者编写一定量的代码（小于五十行）来自定义编码工作。下面我们就来看一下在拆分结束后用户如何取码。")]),t._v(" "),s("h3",{attrs:{id:"_1-读入方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-读入方案"}},[t._v("#")]),t._v(" 1 读入方案")]),t._v(" "),s("p",[t._v("安装好 "),s("code",[t._v("Chai.py")]),t._v(" 后，我们需要在自己的文件中导入 "),s("code",[t._v("Schema")]),t._v(" 类，用它读入自己的方案（这里以 "),s("code",[t._v("wubi98")]),t._v(" 为例），运行拆分：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" Chai "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" Schema\n\nwubi98 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Schema"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'wubi98'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nwubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("run"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("当 "),s("code",[t._v("Schema('wubi98')")]),t._v(" 执行时，系统会首先查看当前文件夹（也就是这行语句所在的程序所在的文件夹）是否含有 "),s("code",[t._v("wubi98.schema.yaml")]),t._v("，如果没有，则在内置文件夹中寻找。由于 "),s("code",[t._v("Schema")]),t._v(" 是一个类，这个操作相当于实例化一个 "),s("code",[t._v("Schema")]),t._v(" 对象，我们将其命名为 "),s("code",[t._v("wubi98")]),t._v("。")]),t._v(" "),s("p",[t._v("然后，"),s("code",[t._v("wubi98.run()")]),t._v(" 则代表的是根据配置文件中所包含的拆分规则和字根选取运行拆分。取决于您的字集大小和拆分规则，这一过程可能会耗时 5 至 10 秒。")]),t._v(" "),s("h3",{attrs:{id:"_2-schema-component-属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-schema-component-属性"}},[t._v("#")]),t._v(" 2 "),s("code",[t._v("Schema.component")]),t._v(" 属性")]),t._v(" "),s("p",[t._v("运行结束后，"),s("code",[t._v("wubi98")]),t._v(" 对象将会生成一个 "),s("code",[t._v("wubi98.component")]),t._v(" 属性，它的结构如下：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    nameChar1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("objectRoot1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" objectRoot2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("其中，"),s("code",[t._v("nameChar")]),t._v(" 是「名义字」，即一个字符串，如 "),s("code",[t._v("'的'")]),t._v("。而 "),s("code",[t._v("objectRoot1, ...")]),t._v(" 则是「对象字根」，它们是自定义类 "),s("code",[t._v("Char")]),t._v(" 的实例。我们接下来就会看到如何利用这些 "),s("code",[t._v("Char")]),t._v(" 类对象进行编码。")]),t._v(" "),s("p",[t._v("但在这之前，我们有必要提醒读者："),s("code",[t._v("wubi98.run()")]),t._v(" 并没有生成所有字的拆分，而是生成了所有「基本部件」的拆分。例如「里」是一个基本部件，它是 "),s("code",[t._v("wubi98.component")]),t._v(" 的键之一，但「理」、「锂」等并不在 "),s("code",[t._v("wubi98.component")]),t._v(" 中。它们的拆法由下面给出的办法定义：")]),t._v(" "),s("h3",{attrs:{id:"_3-schema-tree-属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-schema-tree-属性"}},[t._v("#")]),t._v(" 3 "),s("code",[t._v("Schema.tree")]),t._v(" 属性")]),t._v(" "),s("p",[t._v("例如，"),s("code",[t._v("wubi98.tree")]),t._v(" 的结构如下：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    nameChar1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" tree1\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("其中 "),s("code",[t._v("nameChar")]),t._v(" 和上面相同，而 "),s("code",[t._v("tree")]),t._v(" 则是一个自定义类 "),s("code",[t._v("Tree")]),t._v(" 的实例。"),s("code",[t._v("Tree")]),t._v(" 具有如下属性：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Tree.name")]),t._v("：字名，例如「理」；")]),t._v(" "),s("li",[s("code",[t._v("Tree.structure")]),t._v("：字的结构，例如「理」为左右结构，代码为 "),s("code",[t._v("h")]),t._v("；")]),t._v(" "),s("li",[s("code",[t._v("Tree.first")]),t._v(" 和 "),s("code",[t._v("Tree.second")]),t._v("：字按该结构进行二分之后，得到的第一部分（如王）和第二部分（如里）。")])]),t._v(" "),s("p",[t._v("注意，这些部分仍然是一个 "),s("code",[t._v("Tree")]),t._v(" 对象，如此不断迭代拆分，直到不可再分（即某一部分为基本部件）为止，此时基本部件对应的 "),s("code",[t._v("Tree")]),t._v(" 的 "),s("code",[t._v("first")]),t._v(" 和 "),s("code",[t._v("second")]),t._v(" 属性均为 "),s("code",[t._v("None")]),t._v("，其结构为空。")]),t._v(" "),s("h3",{attrs:{id:"_4-顺序风格编码示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-顺序风格编码示例"}},[t._v("#")]),t._v(" 4 顺序风格编码示例")]),t._v(" "),s("p",[t._v("这里，「顺序风格」指的是类似于五笔的顺序取字根的方式。此时，基本部件按顺序拆分，而其他字先表示为基本部件的序列，然后依次取各个部件的拆分，再合并到一起。这种取码方式用代码表达就是：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" nameChar "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" wubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("charList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" nameChar "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" wubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("component"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        scheme "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" wubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("component"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("nameChar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        tree "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" wubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tree"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("nameChar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n        componentList "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tree"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("flatten"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        scheme "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("sum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("wubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("component"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("component"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" component "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" componentList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("tuple")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("在这里，我们获得合体字的树后，将其打平（"),s("code",[t._v("Tree.flatten()")]),t._v("）为基本部件的列表，它不含有任何嵌套；然后再将各个基本部件的拆分连接起来。显然此时 "),s("code",[t._v("scheme")]),t._v(" 是一个含有若干「对象字根」的元组。然后：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[t._v("code "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("join"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("wubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rootSet"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("objectRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" objectRoot "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" scheme"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这里表示，我们取每个对象字根的名字（实际上此时变成了名义字根），然后用 "),s("code",[t._v("wubi98.rootSet")]),t._v(" 转为编码，就完成了编码。")]),t._v(" "),s("p",[t._v("当然，实际的规则要略为复杂一些，例如我们如何对字根字进行编码呢？假设普通字根字的编码规则为：字根所在键位 + 第一、二、末笔。那么我们可以写：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("scheme"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    objectRoot "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" scheme"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    nameRoot "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name\n    firstStroke "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("strokeList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("type")]),t._v("\n    secondStroke "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("strokeList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("type")]),t._v("\n    lastStroke "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" objectRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("strokeList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("type")]),t._v("\n    info "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("nameRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" firstStroke"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" secondStroke"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" lastStroke"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    code "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("join"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("wubi98"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rootSet"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("nameRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" nameRoot "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" info"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("哈！原来一个对象字根（"),s("code",[t._v("objectRoot")]),t._v("）不仅有名字属性，还有「笔画序列」（"),s("code",[t._v("strokeList")]),t._v("）属性。例如，"),s("code",[t._v("objectRoot.strokeList[0]")]),t._v(" 就取到了该字的第一笔。每一笔都是一个 "),s("code",[t._v("Stroke")]),t._v(" 对象，它具有一个 "),s("code",[t._v("type")]),t._v(" 属性，如「横」，我们将它用 "),s("code",[t._v("rootSet")]),t._v(" 进行映射，就得到了字根字的编码。")]),t._v(" "),s("p",[t._v("本系统还能轻而易举地完成识别码的添加。具体细节请看 GitHub 仓库中的 "),s("code",[t._v("wubi98.py")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_5-二分风格编码示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-二分风格编码示例"}},[t._v("#")]),t._v(" 5 二分风格编码示例")]),t._v(" "),s("p",[t._v("待续。")]),t._v(" "),s("h3",{attrs:{id:"_6-二笔类编码示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-二笔类编码示例"}},[t._v("#")]),t._v(" 6 二笔类编码示例")]),t._v(" "),s("p",[t._v("待续。")])])}),[],!1,null,null,null);a.default=e.exports}}]);
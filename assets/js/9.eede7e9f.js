(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{354:function(a,e,_){"use strict";_.r(e);var t=_(17),v=Object(t.a)({},(function(){var a=this,e=a.$createElement,_=a._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"核心-pychai-core"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#核心-pychai-core"}},[a._v("#")]),a._v(" 核心（"),_("code",[a._v("pychai.core")]),a._v("）")]),a._v(" "),_("h2",{attrs:{id:"基类-core-chai-chai"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基类-core-chai-chai"}},[a._v("#")]),a._v(" 基类（"),_("code",[a._v("core.chai.Chai")]),a._v("）")]),a._v(" "),_("h3",{attrs:{id:"构造函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[a._v("#")]),a._v(" 构造函数")]),a._v(" "),_("p",[a._v("读取各数据库、缓存、配置等。")]),a._v(" "),_("h3",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[a._v("#")]),a._v(" 接口")]),a._v(" "),_("p",[a._v("公有方法：")]),a._v(" "),_("ul",[_("li",[_("code",[a._v("Chai.getComponentScheme")]),a._v("：生成所有部件拆分，结果保存到 "),_("code",[a._v("Chai.COMPONENTS")]),a._v(" 的各个部件中；")]),a._v(" "),_("li",[_("code",[a._v("Chai.getCompoundScheme")]),a._v("：生成所有复合体拆分，结果保存到 "),_("code",[a._v("Chai.COMPOUNDS")]),a._v(" 的各个部件中；")]),a._v(" "),_("li",[_("code",[a._v("Chai.encode")]),a._v("：")])]),a._v(" "),_("p",[a._v("以上三个公有方法均有一个同名的私有方法与之对应，但是私有方法的签名是 "),_("code",[a._v("(self, character: Character)")]),a._v("。")]),a._v(" "),_("h3",{attrs:{id:"输出函数-chai-chai"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#输出函数-chai-chai"}},[a._v("#")]),a._v(" 输出函数（"),_("code",[a._v("Chai.chai")]),a._v("）")]),a._v(" "),_("p",[a._v("依次调用上述三个方法，并把得到的码表保存到给定路径下。")]),a._v(" "),_("h2",{attrs:{id:"顺序中间类-core-sequential-sequential"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#顺序中间类-core-sequential-sequential"}},[a._v("#")]),a._v(" 顺序中间类（"),_("code",[a._v("core.sequential.Sequential")]),a._v("）")]),a._v(" "),_("h3",{attrs:{id:"幂字典生成-sequential-addpowerdict"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#幂字典生成-sequential-addpowerdict"}},[a._v("#")]),a._v(" 幂字典生成（"),_("code",[a._v("Sequential.__addPowerDict")]),a._v("）")]),a._v(" "),_("p",[a._v("我们现在讨论：给定一个基本部件，我们可以从其中拆出哪些字根？为了满足不同方案的需求，「拆」采用了比较激进的方案——枚举一个基本部件的所有切片，计算该切片的特征，然后在退化字典中查找它所对应的字根，如果能够找到则标记为有效切片，找不到则标记为无效切片。")]),a._v(" "),_("p",[a._v("那么，一个基本部件最多能形成多少种切片？显然，对于一个 n 笔的字，每个笔画都有取和不取两种状态，因而切片就有 2 的 n 次方种可能性。我们因此可以用 n 个布尔值（即 0 或 1）组成的向量来表达这一切片。例如：")]),a._v(" "),_("ul",[_("li",[a._v("设字 c 是含有 5 笔的字，则它的所有切片都可以用一个"),_("strong",[a._v("含有 5 个布尔值的向量")]),a._v("表达；")]),a._v(" "),_("li",[a._v("取字 c 前 2 笔和最后一笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的向量应该是 (1, 1, 0, 0, 1)；")]),a._v(" "),_("li",[a._v("取完切片 s 之后，余下部分 r 对应的向量应该是 (0, 0, 1, 1, 0)。")])]),a._v(" "),_("p",[a._v("进一步抽象之后，我们很自然地联想到可以使用二进制数来表达切片，这样的好处是我们可以通过位运算来快速处理切片。例如：")]),a._v(" "),_("ul",[_("li",[a._v("设字 c 是含有 5 笔的字，则它的所有切片都可以用一个"),_("strong",[a._v("含有 5 个位的二进制数")]),a._v("表达；")]),a._v(" "),_("li",[a._v("取字 c 前 2 笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的二进制数应该是 11001，转换为十进制数是 25；")]),a._v(" "),_("li",[a._v("取完切片 s 之后，余下部分 r 对应的向量应该是 00111，转换为十进制数是 6。")])]),a._v(" "),_("p",[a._v("现在，我们就可以通过遍历 1 ~ 2"),_("sup",[a._v("n")]),a._v("-1 的所有数字来寻找一个字的所有有效切片：")]),a._v(" "),_("p",[a._v("现在，幂字典中记录了每个切片分别对应哪个字根（或者不对应任何字根），由此我们可以正式进入一个字的拆分环节。")]),a._v(" "),_("h3",{attrs:{id:"可行拆分集生成-sequential-addschemelist"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可行拆分集生成-sequential-addschemelist"}},[a._v("#")]),a._v(" 可行拆分集生成（"),_("code",[a._v("Sequential.__addSchemeList")]),a._v("）")]),a._v(" "),_("p",[a._v("在未开始拆分之前，我们将一个字的状态用 2"),_("sup",[a._v("n")]),a._v("-1 表示，我们将它称为剩余数。每当我们从这个字上取下一个切片时，我们就将这个切片对应的数从剩余数中减去，得到新的剩余数。那么给定任意一个剩余数，我们如何知道从它身上能取下哪些切片呢？")]),a._v(" "),_("p",[a._v("首先，我们要引入一个限定原则（首笔序原则），即拆分得到的字根列表是按它们首笔笔顺排列的。因此，在每次从没有拆完的部分中取切片的过程中，必须取到该部分的第一笔。例如，第一次拆分时必须取到该字的第一笔。")]),a._v(" "),_("p",[a._v("所以，拆分算法可以概括为：")]),a._v(" "),_("ul",[_("li",[a._v("建立两个列表记录拆分状态，一个为未完成列表，一个为完成列表，向未完成列表中加入初始值 (2"),_("sup",[a._v("n")]),a._v(" - 1)，即将整个部件作为一个剩余数；")]),a._v(" "),_("li",[a._v("取未完成列表中的某个拆分，将它的最后一个数（即剩余数）经由 "),_("code",[a._v("nextRoot")]),a._v(" 函数处理，得到所有可能切片，用幂字典检验它们的有效性，如果无效则予以剔除，有效则保留；")]),a._v(" "),_("li",[a._v("如果切片恰好等于剩余数，说明这个基本部件被拆完了，我们将它添加到已完成列表中；否则用剩余数减去新切片，将它添加到未完成列表中，形成堆栈；")]),a._v(" "),_("li",[a._v("重复上述过程，直到未完成列表全部被清空。")])]),a._v(" "),_("h2",{attrs:{id:"二分中间类-core-dichotomous-dichotomous"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二分中间类-core-dichotomous-dichotomous"}},[a._v("#")]),a._v(" 二分中间类（"),_("code",[a._v("core.dichotomous.Dichotomous")]),a._v("）")]),a._v(" "),_("p",[a._v("TODO")]),a._v(" "),_("h2",{attrs:{id:"四角中间类-core-tetragonal-tetragonal"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四角中间类-core-tetragonal-tetragonal"}},[a._v("#")]),a._v(" 四角中间类（"),_("code",[a._v("core.tetragonal.Tetragonal")]),a._v("）")]),a._v(" "),_("p",[a._v("TODO")])])}),[],!1,null,null,null);e.default=v.exports}}]);